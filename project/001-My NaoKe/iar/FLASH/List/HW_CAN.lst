###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        07/Feb/2019  15:37:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\2019.IAR\lib\LPLD\HW\HW_CAN.c
#    Command line =  
#        D:\2019.IAR\lib\LPLD\HW\HW_CAN.c -D LPLD_K60 -lCN
#        "D:\2019.IAR\project\001-My NaoKe\iar\FLASH\List\" -lB
#        "D:\2019.IAR\project\001-My NaoKe\iar\FLASH\List\" -o
#        "D:\2019.IAR\project\001-My NaoKe\iar\FLASH\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "D:\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\app\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\CPU\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\common\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\LPLD\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\LPLD\HW\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\LPLD\DEV\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\uCOS-II\Ports\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\uCOS-II\Source\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\FatFs\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\FatFs\option\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\USB\common\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\USB\driver\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\USB\descriptor\" -I
#        "D:\2019.IAR\project\001-My NaoKe\iar\..\..\..\lib\USB\class\" -Ol -I
#        "D:\Embedded Workbench 7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  D:\2019.IAR\project\001-My NaoKe\iar\FLASH\List\HW_CAN.lst
#    Object file  =  D:\2019.IAR\project\001-My NaoKe\iar\FLASH\Obj\HW_CAN.o
#
###############################################################################

D:\2019.IAR\lib\LPLD\HW\HW_CAN.c
      1          /**
      2           * @file HW_CAN.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief CAN底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     24          #include "HW_CAN.h"
     25          
     26          //FlexCAN模块设置波特率函数
     27          static void LPLD_CAN_SetBaudRate(CAN_Type *,uint32 );
     28          //FlexCAN 清楚中断标志位函数
     29          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *, uint8 );
     30          //FlexCAN 获得中断标志位函数
     31          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *, uint8 );
     32          //FlexCAN 解锁Msg缓冲区函数
     33          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *);
     34          //FlexCAN 使能Msg缓冲区中断函数
     35          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *, uint8 );
     36          //FlexCAN 设置Msg缓冲区的CODE
     37          static void LPLD_CAN_SetMsgCode(CAN_Type *, uint8 , uint8 );
     38          //FlexCAN 获得Msg缓冲区的CODE
     39          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *, uint8 );
     40          //FlexCAN 获得Msg缓冲区的TIMESTAMP
     41          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *, uint8 );
     42          //FlexCAN 设置Msg缓冲区的ID
     43          void LPLD_CAN_SetMsgID(CAN_Type *, uint8 ,uint32 );
     44          //FlexCAN 获得Msg缓冲区的ID
     45          static uint32 LPLD_CAN_GetMsgID(CAN_Type *, uint8 );
     46          //FlexCAN 设置Msg缓冲区的长度
     47          static void LPLD_CAN_SetMsgLength(CAN_Type *, uint8 ,uint8 );
     48          //FlexCAN 获得Msg缓冲区的长度
     49          uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 MSG_NUM);
     50          //FlexCAN 获得Msg缓冲区的数据
     51          static void LPLD_CAN_GetData(CAN_Type *canx, uint8 , uint8 ,  uint8 *);
     52          //FlexCAN 写Msg缓冲区的数据
     53          static void LPLD_CAN_WriteData(CAN_Type *, uint8 , uint8, uint8 * );
     54          //FlexCAN 传输中断函数
     55          void LPLD_CAN_Transmit_Interrupt(CAN_Type *, uint8 );
     56          //FlexCAN 接收中断函数
     57          static void LPLD_CAN_Receive_Interrupt(CAN_Type *, uint8 );
     58          //FlexCAN CAN0的中断处理函数
     59          static void LPLD_CAN_CAN0_Interrupt_Handler(CAN_MSGOBJ_InitTypeDef *);
     60          //FlexCAN CAN1的中断处理函数
     61          static void LPLD_CAN_CAN1_Interrupt_Handler(CAN_MSGOBJ_InitTypeDef *);
     62          
     63          //设置16个Msg的结构体

   \                                 In section .bss, align 4
     64          CAN_MSGOBJ_InitTypeDef  flexcan_msgobj_param_t[MSG_MAX_NO] = {0};
   \                     flexcan_msgobj_param_t:
   \   00000000                      DS8 256
     65          //设置CANx Msg的中断回掉函数

   \                                 In section .bss, align 4
     66          CAN_ISR_CALLBACK CAN0_ISR[MSG_MAX_NO];
   \                     CAN0_ISR:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     67          CAN_ISR_CALLBACK CAN1_ISR[MSG_MAX_NO];
   \                     CAN1_ISR:
   \   00000000                      DS8 64
     68          
     69          /*
     70           * LPLD_CAN_Init
     71           * 在该函数中使能CANx，设置CANx的波特率，选择相应的工作模式
     72           * 通过CAN_InitTypeDef结构体对CAN进行初始化。
     73           * 
     74           * 参数:
     75           *    CAN_InitTypeDef--can_init_structure
     76           *                     具体定义见HW_CAN.h can_init_structure
     77           *
     78           * 输出:
     79           *    无
     80           *
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void LPLD_CAN_Init(CAN_InitTypeDef can_init_structure)
     83          {
   \                     LPLD_CAN_Init: (+1)
   \   00000000   0xE92D 0x41F7      PUSH     {R0-R2,R4-R8,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
     84            uint8 i;
     85            CAN_Type *canx = can_init_structure.CAN_Canx;
   \   00000006   0x9C01             LDR      R4,[SP, #+4]
     86            uint32 baud = can_init_structure.CAN_BaudRate;
   \   00000008   0x9D02             LDR      R5,[SP, #+8]
     87            uint8  mask_mode = can_init_structure.CAN_RxMaskMode;
   \   0000000A   0xF89D 0x600C      LDRB     R6,[SP, #+12]
     88            PortPinsEnum_Type tx_pin = can_init_structure.CAN_TxPin;
   \   0000000E   0xF89D 0x700D      LDRB     R7,[SP, #+13]
     89            PortPinsEnum_Type rx_pin = can_init_structure.CAN_RxPin;
   \   00000012   0xF89D 0x800E      LDRB     R8,[SP, #+14]
     90          
     91            ASSERT(mask_mode <= CAN_MSGOBJ_GLOBAL_MASKING);
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E02             CMP      R6,#+2
   \   0000001A   0xDB04             BLT.N    ??LPLD_CAN_Init_0
   \   0000001C   0x215B             MOVS     R1,#+91
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000022   0x.... 0x....      BL       assert_failed
     92            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \                     ??LPLD_CAN_Init_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0xf4241
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD304             BCC.N    ??LPLD_CAN_Init_1
   \   0000002E   0x215C             MOVS     R1,#+92
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000034   0x.... 0x....      BL       assert_failed
     93              
     94            OSC->CR |= OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK;
   \                     ??LPLD_CAN_Init_1: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40065000
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable12_4  ;; 0x40065000
   \   00000046   0x7008             STRB     R0,[R1, #+0]
     95            
     96            if(canx == CAN0)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40024000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD108             BNE.N    ??LPLD_CAN_Init_2
     97              SIM->SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x4004803c
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable12_6  ;; 0x4004803c
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE007             B.N      ??LPLD_CAN_Init_3
     98            else
     99              SIM->SCGC3 |= SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Init_2: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40048030
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable12_7  ;; 0x40048030
   \   00000070   0x6008             STR      R0,[R1, #+0]
    100            
    101            if(canx == CAN0)
   \                     ??LPLD_CAN_Init_3: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40024000
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD11E             BNE.N    ??LPLD_CAN_Init_4
    102            {
    103              if(tx_pin == PTB18)//CAN0_TX
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F32             CMP      R7,#+50
   \   0000007E   0xD105             BNE.N    ??LPLD_CAN_Init_5
    104              {
    105                PORTB->PCR[18] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   00000080   0xF240 0x2003      MOVW     R0,#+515
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable12_8  ;; 0x4004a048
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE004             B.N      ??LPLD_CAN_Init_6
    106              }
    107              else
    108              {
    109                PORTA->PCR[12] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_5: (+1)
   \   0000008C   0xF44F 0x7000      MOV      R0,#+512
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable12_9  ;; 0x40049030
   \   00000094   0x6008             STR      R0,[R1, #+0]
    110              }
    111          
    112              if(rx_pin == PTB19)//CAN0_RX
   \                     ??LPLD_CAN_Init_6: (+1)
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0xF1B8 0x0F33      CMP      R8,#+51
   \   0000009E   0xD105             BNE.N    ??LPLD_CAN_Init_7
    113              {
    114                PORTB->PCR[19] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000A0   0xF240 0x2003      MOVW     R0,#+515
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x4004a04c
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE023             B.N      ??LPLD_CAN_Init_8
    115              }
    116              else
    117              {
    118                PORTA->PCR[13] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_7: (+1)
   \   000000AC   0xF44F 0x7000      MOV      R0,#+512
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40049034
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   \   000000B6   0xE01D             B.N      ??LPLD_CAN_Init_8
    119              }
    120            }
    121            else
    122            {
    123              if(tx_pin == PTC17)//CAN1_TX
   \                     ??LPLD_CAN_Init_4: (+1)
   \   000000B8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000BA   0x2F4D             CMP      R7,#+77
   \   000000BC   0xD105             BNE.N    ??LPLD_CAN_Init_9
    124              {
    125                PORTC->PCR[17] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000BE   0xF240 0x2003      MOVW     R0,#+515
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable12_12  ;; 0x4004b044
   \   000000C6   0x6008             STR      R0,[R1, #+0]
   \   000000C8   0xE004             B.N      ??LPLD_CAN_Init_10
    126              }
    127              else
    128              {
    129                PORTE->PCR[24] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_9: (+1)
   \   000000CA   0xF240 0x2003      MOVW     R0,#+515
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable12_13  ;; 0x4004d060
   \   000000D2   0x6008             STR      R0,[R1, #+0]
    130              }
    131          
    132              if(rx_pin == PTC16)//CAN1_RX
   \                     ??LPLD_CAN_Init_10: (+1)
   \   000000D4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D8   0xF1B8 0x0F4C      CMP      R8,#+76
   \   000000DC   0xD105             BNE.N    ??LPLD_CAN_Init_11
    133              {
    134                PORTC->PCR[16] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000DE   0xF240 0x2003      MOVW     R0,#+515
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable12_14  ;; 0x4004b040
   \   000000E6   0x6008             STR      R0,[R1, #+0]
   \   000000E8   0xE004             B.N      ??LPLD_CAN_Init_8
    135              }
    136              else
    137              {
    138                PORTE->PCR[25] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_11: (+1)
   \   000000EA   0xF240 0x2003      MOVW     R0,#+515
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable12_15  ;; 0x4004d064
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    139              }
    140            } 	 
    141            //禁止CAN外设
    142            canx->MCR   |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Init_8: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000FA   0x6020             STR      R0,[R4, #+0]
    143            //只有在LPM_ACK = 1情况下才可以选择钟源
    144            canx->CTRL1 |= CAN_CTRL1_CLKSRC_MASK;  //选择peripheral clock作为CAN外设的时钟源
   \   000000FC   0x6860             LDR      R0,[R4, #+4]
   \   000000FE   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000102   0x6060             STR      R0,[R4, #+4]
    145                                                   //设置此位必须在CAN停止模式下
    146            //在时钟初始化完毕和CAN总线使能完毕后，
    147            //单片机自动进入冻结模式
    148            //只有在冻结模式下才能配置大多数CAN总线寄存器
    149            //使能冻结模式
    150            canx->MCR |= CAN_MCR_HALT_MASK; 
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000010A   0x6020             STR      R0,[R4, #+0]
    151            canx->MCR |= CAN_MCR_FRZ_MASK;
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000112   0x6020             STR      R0,[R4, #+0]
    152            canx->MCR &= ~CAN_MCR_MDIS_MASK; 
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   00000118   0x0840             LSRS     R0,R0,#+1
   \   0000011A   0x6020             STR      R0,[R4, #+0]
    153            
    154            while(!(canx->MCR & CAN_MCR_LPMACK_MASK));	
   \                     ??LPLD_CAN_Init_12: (+1)
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x02C0             LSLS     R0,R0,#+11
   \   00000120   0xD5FC             BPL.N    ??LPLD_CAN_Init_12
    155          
    156            //进行软件复位
    157            canx->MCR ^= CAN_MCR_SOFTRST_MASK;
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF090 0x7000      EORS     R0,R0,#0x2000000
   \   00000128   0x6020             STR      R0,[R4, #+0]
    158            while(canx->MCR & CAN_MCR_SOFTRST_MASK);
   \                     ??LPLD_CAN_Init_13: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x0180             LSLS     R0,R0,#+6
   \   0000012E   0xD4FC             BMI.N    ??LPLD_CAN_Init_13
    159                      
    160            //等待进入冻结模式 
    161            while(!(canx->MCR & CAN_MCR_FRZACK_MASK));
   \                     ??LPLD_CAN_Init_14: (+1)
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x01C0             LSLS     R0,R0,#+7
   \   00000134   0xD5FC             BPL.N    ??LPLD_CAN_Init_14
    162            
    163            if(mask_mode == CAN_MSGOBJ_GLOBAL_MASKING)
   \   00000136   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000138   0x2E01             CMP      R6,#+1
   \   0000013A   0xD104             BNE.N    ??LPLD_CAN_Init_15
    164            {
    165              canx->MCR &= ~CAN_MCR_IRMQ_MASK;   //使能全局匹配寄存器禁止单独匹配 
   \   0000013C   0x6820             LDR      R0,[R4, #+0]
   \   0000013E   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000142   0x6020             STR      R0,[R4, #+0]
   \   00000144   0xE003             B.N      ??LPLD_CAN_Init_16
    166            }
    167            else
    168            {
    169              canx->MCR |= CAN_MCR_IRMQ_MASK;   //使能Msg单独匹配 
   \                     ??LPLD_CAN_Init_15: (+1)
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000014C   0x6020             STR      R0,[R4, #+0]
    170            }
    171            
    172            canx->MCR |= CAN_MCR_SUPV_MASK ;   //设置成管理模式 
   \                     ??LPLD_CAN_Init_16: (+1)
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000154   0x6020             STR      R0,[R4, #+0]
    173            canx->MCR |= CAN_MCR_SRXDIS_MASK ; //禁止自我接收
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000015C   0x6020             STR      R0,[R4, #+0]
    174            canx->MCR &= ~CAN_MCR_WRNEN_MASK;  //不产生警告中断
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000164   0x6020             STR      R0,[R4, #+0]
    175            canx->MCR &= ~CAN_MCR_RFEN_MASK ;  //禁止接收FIFO
   \   00000166   0x6820             LDR      R0,[R4, #+0]
   \   00000168   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \   0000016C   0x6020             STR      R0,[R4, #+0]
    176            canx->MCR &= ~CAN_MCR_AEN_MASK;    //禁止Abort
   \   0000016E   0x6820             LDR      R0,[R4, #+0]
   \   00000170   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000174   0x6020             STR      R0,[R4, #+0]
    177            canx->MCR &= ~CAN_MCR_LPRIOEN_MASK;//禁止本地优先
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000017C   0x6020             STR      R0,[R4, #+0]
    178            
    179            //配置相关的寄存器
    180            canx->CTRL2 |= CAN_CTRL2_EACEN_MASK; //接收邮箱过滤IDE匹配，RTR不匹配
   \   0000017E   0x6B60             LDR      R0,[R4, #+52]
   \   00000180   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000184   0x6360             STR      R0,[R4, #+52]
    181            canx->CTRL2 &= ~CAN_CTRL2_RRS_MASK;  //不自动产生远程请求帧产生
   \   00000186   0x6B60             LDR      R0,[R4, #+52]
   \   00000188   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   0000018C   0x6360             STR      R0,[R4, #+52]
    182            canx->CTRL2 |= CAN_CTRL2_MRP_MASK;   //ID首先从邮箱中匹配
   \   0000018E   0x6B60             LDR      R0,[R4, #+52]
   \   00000190   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000194   0x6360             STR      R0,[R4, #+52]
    183          
    184            //canx->CTRL1 |= CAN_CTRL1_LBUF_MASK;  //发送的时候从低Msg开始
    185            canx->CTRL1 &= ~CAN_CTRL1_LBUF_MASK;   //发送的时候从低优先级发送
   \   00000196   0x6860             LDR      R0,[R4, #+4]
   \   00000198   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000019C   0x6060             STR      R0,[R4, #+4]
    186                                       
    187            //canx->CTRL1 |= CAN_CTRL1_LPB_MASK;  //loop 模式,用于测试
    188            canx->CTRL1 &= ~CAN_CTRL1_LPB_MASK;   //使用正常模式
   \   0000019E   0x6860             LDR      R0,[R4, #+4]
   \   000001A0   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   000001A4   0x6060             STR      R0,[R4, #+4]
    189            //设置CAN总线通信的波特率
    190            LPLD_CAN_SetBaudRate(canx,baud);
   \   000001A6   0x0029             MOVS     R1,R5
   \   000001A8   0x0020             MOVS     R0,R4
   \   000001AA   0x.... 0x....      BL       LPLD_CAN_SetBaudRate
    191            //清空CAN自由计数器 
    192            canx->TIMER = 0x0000; 
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x60A0             STR      R0,[R4, #+8]
    193            //将MB_MAX个邮箱缓冲区内容清0
    194            for(i = 0;i < MSG_MAX_NO; i++)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0xE018             B.N      ??LPLD_CAN_Init_17
    195            {
    196              canx->MB[i].CS    = 0x00000000;
   \                     ??LPLD_CAN_Init_18: (+1)
   \   000001B6   0x2100             MOVS     R1,#+0
   \   000001B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BA   0xEB14 0x1200      ADDS     R2,R4,R0, LSL #+4
   \   000001BE   0xF8C2 0x1080      STR      R1,[R2, #+128]
    197              canx->MB[i].ID    = 0x00000000;
   \   000001C2   0x2100             MOVS     R1,#+0
   \   000001C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C6   0xEB14 0x1200      ADDS     R2,R4,R0, LSL #+4
   \   000001CA   0xF8C2 0x1084      STR      R1,[R2, #+132]
    198              canx->MB[i].WORD0 = 0x00000000;
   \   000001CE   0x2100             MOVS     R1,#+0
   \   000001D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D2   0xEB14 0x1200      ADDS     R2,R4,R0, LSL #+4
   \   000001D6   0xF8C2 0x1088      STR      R1,[R2, #+136]
    199              canx->MB[i].WORD1 = 0x00000000;        
   \   000001DA   0x2100             MOVS     R1,#+0
   \   000001DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DE   0xEB14 0x1200      ADDS     R2,R4,R0, LSL #+4
   \   000001E2   0xF8C2 0x108C      STR      R1,[R2, #+140]
    200            }
   \   000001E6   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPLD_CAN_Init_17: (+1)
   \   000001E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EA   0x2810             CMP      R0,#+16
   \   000001EC   0xDBE3             BLT.N    ??LPLD_CAN_Init_18
    201            //清除64个邮箱的标志位
    202            canx->IFLAG1 = 0xFFFFFFFF;
   \   000001EE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001F2   0x6320             STR      R0,[R4, #+48]
    203            canx->IFLAG2 = 0xFFFFFFFF;
   \   000001F4   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001F8   0x62E0             STR      R0,[R4, #+44]
    204            //禁止邮箱中断
    205            canx->IMASK1 = 0x00000000;
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0x62A0             STR      R0,[R4, #+40]
    206            canx->IMASK2 = 0x00000000;
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x6260             STR      R0,[R4, #+36]
    207             /*
    208            如果MCR的IRMQ为1，表示每个邮箱都可以单独进行ID匹配
    209            注意：如果是low cost MCUs（低配置的MCU），没有单独匹配这项功能。
    210                    1\ID匹配会选择free to receive状态的邮箱作为胜者，
    211                    获胜的邮箱可以从接收缓冲区内将接收的帧 Move in 到MB中；
    212                    2\如果出现ID号相同的邮箱，会首先从序号低的邮箱进行匹配，如果
    213                    低序号邮箱是non free to receive状态，那么匹配过程将会查找
    214                    下一个邮箱直到找到free to receive状态且ID相同的邮箱；
    215                    3\如果ID号相同的邮箱都处于non free to receive状态，那么匹配过程
    216                    将停止在最后一个有相同ID的邮箱位置，将帧Move in 到MB中并且将该邮
    217                    箱的状态设置成OVERRUN。
    218                    RXIMR[i]存储在单片机的RAM中，只有在CAN冻结模式下可写。
    219                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK不起作用
    220            */
    221          
    222            for(i = 0;i < MSG_MAX_NO; i++)
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0xE007             B.N      ??LPLD_CAN_Init_19
    223            {
    224              canx->RXIMR[i] = 0x1FFFFFFF;//设置邮箱29位全部屏蔽
   \                     ??LPLD_CAN_Init_20: (+1)
   \   00000206   0xF07F 0x4160      MVNS     R1,#-536870912
   \   0000020A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020C   0xEB14 0x0280      ADDS     R2,R4,R0, LSL #+2
   \   00000210   0xF8C2 0x1880      STR      R1,[R2, #+2176]
    225            }
   \   00000214   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPLD_CAN_Init_19: (+1)
   \   00000216   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000218   0x2810             CMP      R0,#+16
   \   0000021A   0xDBF4             BLT.N    ??LPLD_CAN_Init_20
    226           /*
    227            如果MCR的IRMQ为0，表示使用全局匹配寄存器进行匹配，
    228                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK起作用；
    229                    CANx_RXMGMASK管理除CANx_RX14MASK、CANx_RX15MASK以外的所有Msg；
    230                    ID匹配过程会停止在找到的第一个ID相同的邮箱位置，不管该邮箱是否处于
    231                    free to receive状态。
    232            */
    233          
    234            canx->RXMGMASK = 0x1FFFFFFF; //29位ID全部匹配            
   \   0000021C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000220   0x6120             STR      R0,[R4, #+16]
    235            canx->RX14MASK = 0x1FFFFFFF;
   \   00000222   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000226   0x6160             STR      R0,[R4, #+20]
    236            canx->RX15MASK = 0x1FFFFFFF; 
   \   00000228   0xF07F 0x4060      MVNS     R0,#-536870912
   \   0000022C   0x61A0             STR      R0,[R4, #+24]
    237          
    238            canx->MCR &= ~CAN_MCR_FRZ_MASK; //退出冻结模式
   \   0000022E   0x6820             LDR      R0,[R4, #+0]
   \   00000230   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \   00000234   0x6020             STR      R0,[R4, #+0]
    239            //等待直到退出冻结模式
    240            while( canx->MCR & CAN_MCR_FRZACK_MASK); 
   \                     ??LPLD_CAN_Init_21: (+1)
   \   00000236   0x6820             LDR      R0,[R4, #+0]
   \   00000238   0x01C0             LSLS     R0,R0,#+7
   \   0000023A   0xD4FC             BMI.N    ??LPLD_CAN_Init_21
    241            //只有在冻结模式下才能配置，配置完推出冻结模式
    242            canx->MCR &= ~(CAN_MCR_HALT_MASK); 
   \   0000023C   0x6820             LDR      R0,[R4, #+0]
   \   0000023E   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000242   0x6020             STR      R0,[R4, #+0]
    243            //等到不在冻结模式，休眠模式或者停止模式
    244            while( canx->MCR & CAN_MCR_NOTRDY_MASK);
   \                     ??LPLD_CAN_Init_22: (+1)
   \   00000244   0x6820             LDR      R0,[R4, #+0]
   \   00000246   0x0100             LSLS     R0,R0,#+4
   \   00000248   0xD4FC             BMI.N    ??LPLD_CAN_Init_22
    245            //使能CAN外设
    246            canx->MCR &= ~CAN_MCR_MDIS_MASK;
   \   0000024A   0x6820             LDR      R0,[R4, #+0]
   \   0000024C   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   0000024E   0x0840             LSRS     R0,R0,#+1
   \   00000250   0x6020             STR      R0,[R4, #+0]
    247          }
   \   00000252   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
    248          /*
    249           * LPLD_CAN_SetBaudRate
    250           * 设置CAN波特率
    251           * 参数:
    252           *    CAN_Type *canx
    253           *      |___CAN0 --CAN0号模块
    254           *      |___CAN1 --CAN0号模块
    255           *    baud 波特率
    256           *      |__CAN_BAUD_RATE_50KBPS  --波特率50KBPS
    257           *      |__CAN_BAUD_RATE_100KBPS --波特率100KBPS
    258           *      |__CAN_BAUD_RATE_250KBPS --波特率250KBPS
    259           *      |__CAN_BAUD_RATE_500KBPS --波特率500KBPS
    260           *      |__CAN_BAUD_RATE_1MBPS   --波特率1MBPS
    261           *  输出：
    262           *    无
    263          */

   \                                 In section .text, align 2, keep-with-next
    264          static void LPLD_CAN_SetBaudRate(CAN_Type *canx,uint32 baud)
    265          {
   \                     LPLD_CAN_SetBaudRate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    266            uint8 prescale;
    267            //1个CAN总线位的时间量子：Time Quanta = SYNC_SEG + (PROP_SEG + PSEG1 + 2) + (PSEG2 + 1)，
    268            //SYNC_SEG =  1 （固定值）
    269            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0xf4241
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD305             BCC.N    ??LPLD_CAN_SetBaudRate_0
   \   0000000E   0xF240 0x110D      MOVW     R1,#+269
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000016   0x.... 0x....      BL       assert_failed
    270            switch(baud)
   \                     ??LPLD_CAN_SetBaudRate_0: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xF24C 0x3150      MOVW     R1,#+50000
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD022             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable12_16  ;; 0x186a0
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD01E             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable12_17  ;; 0x3d090
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD01A             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable12_18  ;; 0x7a120
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD016             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable12_19  ;; 0xf4240
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD125             BNE.N    ??LPLD_CAN_SetBaudRate_2
    271            {
    272              case CAN_BAUD_RATE_1MBPS:
    273                {
    274                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,10); 
   \                     ??LPLD_CAN_SetBaudRate_3: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x210A             MOVS     R1,#+10
   \   0000004C   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000050   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000054   0x1E40             SUBS     R0,R0,#+1
    275                  //设置CAN总线通信的波特率
    276                  canx->CTRL1 |= CAN_CTRL1_RJW(2) 
    277                           | CAN_CTRL1_PROPSEG(2)  
    278                           | CAN_CTRL1_PSEG1(2) 
    279                           | CAN_CTRL1_PSEG2(2)
    280                           | CAN_CTRL1_PRESDIV(prescale); 
   \   00000056   0x6861             LDR      R1,[R4, #+4]
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x0600             LSLS     R0,R0,#+24
   \   0000005C   0xF440 0x0012      ORR      R0,R0,#0x920000
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x4308             ORRS     R0,R0,R1
   \   00000066   0x6060             STR      R0,[R4, #+4]
    281                  break;
   \   00000068   0xE012             B.N      ??LPLD_CAN_SetBaudRate_4
    282                }
    283              case CAN_BAUD_RATE_500KBPS:
    284              case CAN_BAUD_RATE_250KBPS:
    285              case CAN_BAUD_RATE_100KBPS:
    286              case CAN_BAUD_RATE_50KBPS:
    287                {
    288                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,20); 
   \                     ??LPLD_CAN_SetBaudRate_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x2114             MOVS     R1,#+20
   \   00000072   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000076   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
    289                  //设置CAN总线通信的波特率
    290                  canx->CTRL1 |= CAN_CTRL1_RJW(2) 
    291                           | CAN_CTRL1_PROPSEG(6)  
    292                           | CAN_CTRL1_PSEG1(6) 
    293                           | CAN_CTRL1_PSEG2(4)
    294                           | CAN_CTRL1_PRESDIV(prescale); 
   \   0000007C   0x6861             LDR      R1,[R4, #+4]
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x0600             LSLS     R0,R0,#+24
   \   00000082   0xF440 0x0034      ORR      R0,R0,#0xB40000
   \   00000086   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   0000008A   0x4308             ORRS     R0,R0,R1
   \   0000008C   0x6060             STR      R0,[R4, #+4]
    295                  break;
   \   0000008E   0xE7FF             B.N      ??LPLD_CAN_SetBaudRate_4
    296                }
    297              default:break;
    298            }
    299          }
   \                     ??LPLD_CAN_SetBaudRate_2: (+1)
   \                     ??LPLD_CAN_SetBaudRate_4: (+1)
   \   00000090   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    300          
    301          /*
    302           * LPLD_CAN_Deinit
    303           * CAN反初始化函数，在该函数中禁止CANx的总线时钟，禁止模块中断，关闭CAN模块
    304           * 
    305           * 参数:
    306           *    CAN_InitTypeDef--can_init_structure
    307           *                     具体定义见HW_CAN.h can_init_structure
    308           * 输出:
    309           *    无
    310           *
    311          */

   \                                 In section .text, align 2, keep-with-next
    312          void LPLD_CAN_Deinit(CAN_InitTypeDef can_init_structure)
    313          {
   \                     LPLD_CAN_Deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    314            CAN_Type *canx = can_init_structure.CAN_Canx;
   \   00000002   0x0004             MOVS     R4,R0
    315            
    316            if(canx == CAN0)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40024000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD10B             BNE.N    ??LPLD_CAN_Deinit_0
    317            {
    318              SIM->SCGC6 &= ~SIM_SCGC6_FLEXCAN0_MASK;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x4004803c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_6  ;; 0x4004803c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    319              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000001C   0x201D             MOVS     R0,#+29
   \   0000001E   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000022   0xE00A             B.N      ??LPLD_CAN_Deinit_1
    320            }
    321            else
    322            {
    323              SIM->SCGC3 &= ~SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Deinit_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40048030
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable12_7  ;; 0x40048030
   \   00000032   0x6008             STR      R0,[R1, #+0]
    324              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   00000034   0x2025             MOVS     R0,#+37
   \   00000036   0x.... 0x....      BL       NVIC_EnableIRQ
    325            }
    326            //禁止CAN外设
    327            canx->MCR |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Deinit_1: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000040   0x6020             STR      R0,[R4, #+0]
    328            canx->MCR |= CAN_MCR_HALT_MASK; 
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000048   0x6020             STR      R0,[R4, #+0]
    329            canx->MCR |= CAN_MCR_FRZ_MASK;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000050   0x6020             STR      R0,[R4, #+0]
    330          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    331          /*
    332           * LPLD_CAN_EnableIrq
    333           * 使能CAN模块中断
    334           * 
    335           * 参数:
    336           *    CAN_InitTypeDef--can_init_structure
    337           *                     具体定义见HW_CAN.h can_init_structure
    338           * 输出:
    339           *    无
    340           *
    341          */

   \                                 In section .text, align 2, keep-with-next
    342          void LPLD_CAN_EnableIrq(CAN_InitTypeDef can_init_structure)
    343          {
   \                     LPLD_CAN_EnableIrq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    344            CAN_Type *canx = can_init_structure.CAN_Canx;
    345              
    346            if(canx == CAN0)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x40024000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD103             BNE.N    ??LPLD_CAN_EnableIrq_0
    347            {
    348              enable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000000A   0x201D             MOVS     R0,#+29
   \   0000000C   0x.... 0x....      BL       NVIC_EnableIRQ
   \   00000010   0xE006             B.N      ??LPLD_CAN_EnableIrq_1
    349            }
    350            else if(canx == CAN1)
   \                     ??LPLD_CAN_EnableIrq_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable12_21  ;; 0x400a4000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD102             BNE.N    ??LPLD_CAN_EnableIrq_1
    351            {
    352              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       NVIC_EnableIRQ
    353            }
    354          }
   \                     ??LPLD_CAN_EnableIrq_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    355          
    356          /*
    357           * LPLD_CAN_DisableIrq
    358           * 禁止CAN模块中断
    359           * 
    360           * 参数:
    361           *    CAN_InitTypeDef--can_init_structure
    362           *                     具体定义见HW_CAN.h can_init_structure
    363           * 输出:
    364           *    无
    365           *
    366          */

   \                                 In section .text, align 2, keep-with-next
    367          void LPLD_CAN_DisableIrq(CAN_InitTypeDef can_init_structure)
    368          {
   \                     LPLD_CAN_DisableIrq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    369            CAN_Type *canx = can_init_structure.CAN_Canx;
    370              
    371            if(canx == CAN0)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x40024000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD103             BNE.N    ??LPLD_CAN_DisableIrq_0
    372            {
    373              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000000A   0x201D             MOVS     R0,#+29
   \   0000000C   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000010   0xE006             B.N      ??LPLD_CAN_DisableIrq_1
    374            }
    375            else if(canx == CAN1)
   \                     ??LPLD_CAN_DisableIrq_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable12_21  ;; 0x400a4000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD102             BNE.N    ??LPLD_CAN_DisableIrq_1
    376            {
    377              disable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       NVIC_DisableIRQ
    378            }
    379          }
   \                     ??LPLD_CAN_DisableIrq_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    380          
    381          /*
    382           * LPLD_CAN_InitMessageObject
    383           *
    384           * 设置CAN Message buffer（Msg）格式，通过CAN_MSGOBJ_InitTypeDef
    385           * 结构体对CAN Message buffer进行初始化。
    386           * 
    387           * 参数:
    388           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    389           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    390           *    message_id
    391           *      设置message_id，id长度根据CAN_MSGOBJ_InitTypeDef的参数而定
    392           *      id的长度分为11位标准帧和29位扩展帧两种
    393           *      CAN_MSGOBJ_ID_STD 表示标准帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_STD
    394           *      此时message_id最长为11位，不能超过0x0FFF；
    395           *      CAN_MSGOBJ_ID_EXT 表示扩展帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_EXT
    396           *      此时message_id最长为29位，不能超过0x1FFFFFFF；
    397           * 输出:
    398           *    无
    399           *
    400           */

   \                                 In section .text, align 2, keep-with-next
    401          void LPLD_CAN_InitMessageObject(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,uint32 message_id)	
    402          {
   \                     LPLD_CAN_InitMessageObject: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
    403            uint32    cs_temp;
    404            uint8     msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \   00000002   0xF89D 0x4004      LDRB     R4,[SP, #+4]
    405            CAN_Type *canx_ptr      = can_msg_init_structure.CAN_Canx;
   \   00000006   0x9D00             LDR      R5,[SP, #+0]
    406            
    407            CAN_ISR_CALLBACK isr_func = can_msg_init_structure.CAN_Isr;
   \   00000008   0x9E03             LDR      R6,[SP, #+12]
    408            
    409            cs_temp = CAN_MB_CS_RTR(can_msg_init_structure.CAN_MsgRTR) | \
    410                      CAN_MB_CS_SRR(can_msg_init_structure.CAN_MsgSRR) | \
    411                      CAN_MB_CS_IDE(can_msg_init_structure.CAN_MsgIdLength) |\
    412                      CAN_MB_CS_DLC(can_msg_init_structure.CAN_MsgDataLength);
   \   0000000A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000000E   0x0500             LSLS     R0,R0,#+20
   \   00000010   0xF410 0x1080      ANDS     R0,R0,#0x100000
   \   00000014   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   00000018   0x0589             LSLS     R1,R1,#+22
   \   0000001A   0xF411 0x0180      ANDS     R1,R1,#0x400000
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000024   0x0549             LSLS     R1,R1,#+21
   \   00000026   0xF411 0x1100      ANDS     R1,R1,#0x200000
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000030   0x0409             LSLS     R1,R1,#+16
   \   00000032   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   00000036   0x4308             ORRS     R0,R1,R0
    413            //根据CAN_MsgDirection的类型设置Msg是发送功能还是接收功能
    414            if(can_msg_init_structure.CAN_MsgDirection == CAN_MSGOBJ_DIR_TX)
   \   00000038   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000003C   0x2902             CMP      R1,#+2
   \   0000003E   0xD102             BNE.N    ??LPLD_CAN_InitMessageObject_0
    415            {
    416              cs_temp |= CAN_MB_CS_CODE(CAN_MSGOBJ_TX_INACTIVE);
   \   00000040   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000044   0xE005             B.N      ??LPLD_CAN_InitMessageObject_1
    417            }
    418            else if(can_msg_init_structure.CAN_MsgDirection == CAN_MSGOBJ_DIR_RX)
   \                     ??LPLD_CAN_InitMessageObject_0: (+1)
   \   00000046   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000004A   0x2901             CMP      R1,#+1
   \   0000004C   0xD101             BNE.N    ??LPLD_CAN_InitMessageObject_1
    419            {
    420              cs_temp |= CAN_MB_CS_CODE(CAN_MSGOBJ_RX_EMPTY);
   \   0000004E   0xF050 0x6080      ORRS     R0,R0,#0x4000000
    421            }
    422            //设置Msg CODE的初始值
    423            //如果是发送模式设置成为INACTIVE状态
    424            //如果是接收模式设置成为EMPTY状态
    425            canx_ptr->MB[msg_num_temp].CS = cs_temp;
   \                     ??LPLD_CAN_InitMessageObject_1: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0xEB15 0x1104      ADDS     R1,R5,R4, LSL #+4
   \   00000058   0xF8C1 0x0080      STR      R0,[R1, #+128]
    426            //设置Msg ID
    427            LPLD_CAN_SetMsgID(canx_ptr,msg_num_temp,message_id); 
   \   0000005C   0x9A08             LDR      R2,[SP, #+32]
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       LPLD_CAN_SetMsgID
    428            //
    429            if(can_msg_init_structure.CAN_MsgInterrupt == TRUE)
   \   00000068   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD11A             BNE.N    ??LPLD_CAN_InitMessageObject_2
    430            {
    431              LPLD_CAN_EnableMsgInterrupt(canx_ptr,msg_num_temp);//使能Msg中断 
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       LPLD_CAN_EnableMsgInterrupt
    432              //设置Msg中断回掉函数
    433              if(canx_ptr == CAN0)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40024000
   \   0000007E   0x4285             CMP      R5,R0
   \   00000080   0xD108             BNE.N    ??LPLD_CAN_InitMessageObject_3
    434              {
    435                if(isr_func != NULL)
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD01F             BEQ.N    ??LPLD_CAN_InitMessageObject_4
    436                {
    437                  CAN0_ISR[msg_num_temp] = isr_func;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable12_22
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
   \   00000092   0xE019             B.N      ??LPLD_CAN_InitMessageObject_4
    438                }
    439              }
    440              else
    441              {
    442                if(isr_func != NULL)
   \                     ??LPLD_CAN_InitMessageObject_3: (+1)
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD016             BEQ.N    ??LPLD_CAN_InitMessageObject_4
    443                {
    444                  CAN1_ISR[msg_num_temp] = isr_func;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_23
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
   \   000000A4   0xE010             B.N      ??LPLD_CAN_InitMessageObject_4
    445                }
    446              }
    447            }
    448            else
    449            {
    450              if(canx_ptr == CAN0)
   \                     ??LPLD_CAN_InitMessageObject_2: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40024000
   \   000000AA   0x4285             CMP      R5,R0
   \   000000AC   0xD106             BNE.N    ??LPLD_CAN_InitMessageObject_5
    451              {
    452                  CAN0_ISR[msg_num_temp] = NULL; 
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable12_22
   \   000000B4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B6   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   000000BA   0xE005             B.N      ??LPLD_CAN_InitMessageObject_4
    453              }
    454              else
    455              {
    456                  CAN1_ISR[msg_num_temp] = NULL;
   \                     ??LPLD_CAN_InitMessageObject_5: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable12_23
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    457              }
    458            }
    459          }
   \                     ??LPLD_CAN_InitMessageObject_4: (+1)
   \   000000C8   0xBD7F             POP      {R0-R6,PC}       ;; return
    460          
    461          /*
    462           * LPLD_CAN_TransmitMessage
    463           * CAN 发送消息函数
    464           * 参数:
    465           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    466           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    467           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    468           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    469           *    该结构体用于定义CAN的消息格式，当CAN发送消息时，会从CAN_MessageFormat_TypeDef定义的结构体对象中
    470           *    提取信息并存储到MSG中，MSG会将消息发送到CAN总线上。
    471           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    472           * 输出:
    473           *    1 发送完毕
    474           *    0 发送失败
    475           *
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          uint8 LPLD_CAN_TransmitMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,\
    478                                         CAN_MessageFormat_TypeDef *can_tx_msg )
    479          {
   \                     LPLD_CAN_TransmitMessage: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
    480            uint8  request;
    481            uint8  msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \   00000004   0xF89D 0x4004      LDRB     R4,[SP, #+4]
    482            CAN_Type *canx_ptr   = can_msg_init_structure.CAN_Canx;
   \   00000008   0x9D00             LDR      R5,[SP, #+0]
   \   0000000A   0x980A             LDR      R0,[SP, #+40]
    483            uint32  message_id = can_tx_msg->CAN_MsgID;  
   \   0000000C   0x6806             LDR      R6,[R0, #+0]
    484            uint8  *in_data_buffer = can_tx_msg->CAN_MsgDataBuffer;
   \   0000000E   0x1D87             ADDS     R7,R0,#+6
    485            uint8   in_data_length = can_tx_msg->CAN_MsgDataLength;
   \   00000010   0xF890 0x800E      LDRB     R8,[R0, #+14]
    486            //如果发送Msg缓冲区中的CODE不等于CAN_MSGOBJ_TX_UNCONDITIONAL
    487            if( LPLD_CAN_GetMsgCode(canx_ptr,msg_num_temp) != CAN_MSGOBJ_TX_UNCONDITIONAL)
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       LPLD_CAN_GetMsgCode
   \   0000001E   0x280C             CMP      R0,#+12
   \   00000020   0xD02E             BEQ.N    ??LPLD_CAN_TransmitMessage_0
    488            {
    489              //向发送Msg缓冲区中的CODE中写INACTIVE命令
    490              canx_ptr->MB[msg_num_temp].CS |= CAN_MB_CS_CODE(CAN_MSGOBJ_TX_INACTIVE);
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0xEB15 0x1004      ADDS     R0,R5,R4, LSL #+4
   \   00000028   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000002C   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xEB15 0x1104      ADDS     R1,R5,R4, LSL #+4
   \   00000036   0xF8C1 0x0080      STR      R0,[R1, #+128]
    491              //设置Msg的ID
    492              LPLD_CAN_SetMsgID(canx_ptr,msg_num_temp,message_id);
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       LPLD_CAN_SetMsgID
    493              //向Msg中写入要发送的数据
    494              LPLD_CAN_WriteData(canx_ptr,msg_num_temp,in_data_length,in_data_buffer);
   \   00000046   0x003B             MOVS     R3,R7
   \   00000048   0x4642             MOV      R2,R8
   \   0000004A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004C   0x0021             MOVS     R1,R4
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       LPLD_CAN_WriteData
    495              //设置Msg的长度
    496              LPLD_CAN_SetMsgLength(canx_ptr,msg_num_temp,in_data_length);
   \   00000056   0x4642             MOV      R2,R8
   \   00000058   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005A   0x0021             MOVS     R1,R4
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       LPLD_CAN_SetMsgLength
    497              //向发送Msg缓冲区中的CODE中写TX_UNCONDITIONAL命令，等待发送完成
    498              canx_ptr->MB[msg_num_temp].CS |= CAN_MB_CS_CODE(CAN_MSGOBJ_TX_UNCONDITIONAL);
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0xEB15 0x1004      ADDS     R0,R5,R4, LSL #+4
   \   0000006A   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000006E   0xF050 0x6040      ORRS     R0,R0,#0xC000000
   \   00000072   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000074   0xEB15 0x1104      ADDS     R1,R5,R4, LSL #+4
   \   00000078   0xF8C1 0x0080      STR      R0,[R1, #+128]
    499              //如果开启发送中断，发送完毕后会触发中断
    500              request = 1;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE000             B.N      ??LPLD_CAN_TransmitMessage_1
    501            }
    502            else
    503            {
    504              request = 0;
   \                     ??LPLD_CAN_TransmitMessage_0: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
    505            }
    506            return (request);
   \                     ??LPLD_CAN_TransmitMessage_1: (+1)
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xB004             ADD      SP,SP,#+16
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    507          }
    508          
    509          /*
    510           * LPLD_CAN_ReceivedMessage
    511           * CAN 处理接收函数，此函数一般在CAN中断函数中调用
    512           * 参数:
    513           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    514           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    515           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    516           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    517           *    该结构体用于定义CAN的消息格式，当CAN成功接收消息以后，会从MSG中将信息存储到
    518           *    CAN_MessageFormat_TypeDef定义的结构体对象中。
    519           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    520           *    
    521           *  输出：
    522           *    无
    523           */

   \                                 In section .text, align 2, keep-with-next
    524          void LPLD_CAN_ReceivedMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,\
    525                                        CAN_MessageFormat_TypeDef *can_rx_msg)
    526          {
   \                     LPLD_CAN_ReceivedMessage: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    527            uint32 message_code,i;
    528            volatile uint16 timer;
    529            uint8 rx_data[CAN_DATA_MAX_BYTES];
    530            uint8 data_length;
    531            uint16 time_stamp;
    532            uint32 msg_id;
    533            CAN_Type *canx = can_msg_init_structure.CAN_Canx;
   \   00000004   0x9C03             LDR      R4,[SP, #+12]
    534            uint8 msg_num = can_msg_init_structure.CAN_MsgNum;
   \   00000006   0xF89D 0x5010      LDRB     R5,[SP, #+16]
    535            //获得Msg缓冲区中的code值
    536            message_code = LPLD_CAN_GetMsgCode(canx,msg_num);
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       LPLD_CAN_GetMsgCode
    537            
    538            if ((message_code != CAN_MSGOBJ_RX_BUSY) && 
    539               (message_code != CAN_MSGOBJ_RX_OVERRUN))
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD03E             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD03C             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
    540            {
    541              //读取ID(可选)
    542              msg_id = LPLD_CAN_GetMsgID(canx, msg_num);
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       LPLD_CAN_GetMsgID
   \   00000026   0x0006             MOVS     R6,R0
    543             
    544              //读取Msg缓冲区接收数据的长度
    545              data_length    = (uint8_t)LPLD_CAN_GetMsgLength(canx, msg_num);
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       LPLD_CAN_GetMsgLength
   \   00000032   0x0007             MOVS     R7,R0
    546              //读取Msg缓冲区接收数据
    547              LPLD_CAN_GetData(canx, msg_num,data_length,rx_data);
   \   00000034   0xAB01             ADD      R3,SP,#+4
   \   00000036   0x003A             MOVS     R2,R7
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       LPLD_CAN_GetData
    548              //获得Msg缓冲区时间戳
    549              time_stamp = LPLD_CAN_GetMsgTimeStamp(canx, msg_num);
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       LPLD_CAN_GetMsgTimeStamp
    550              
    551              for(i = data_length; i < 8; i++)
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x0039             MOVS     R1,R7
   \   00000052   0xE003             B.N      ??LPLD_CAN_ReceivedMessage_1
    552              {
    553                 rx_data[i] = 0;
   \                     ??LPLD_CAN_ReceivedMessage_2: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0xAB01             ADD      R3,SP,#+4
   \   00000058   0x54CA             STRB     R2,[R1, R3]
    554              }
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??LPLD_CAN_ReceivedMessage_1: (+1)
   \   0000005C   0x2908             CMP      R1,#+8
   \   0000005E   0xD3F9             BCC.N    ??LPLD_CAN_ReceivedMessage_2
   \   00000060   0x9B0C             LDR      R3,[SP, #+48]
    555              //将MSG中的消息存储到can_rx_msg中
    556              can_rx_msg->CAN_MsgID = msg_id;
   \   00000062   0x601E             STR      R6,[R3, #+0]
    557              can_rx_msg->CAN_MsgDataLength = data_length;
   \   00000064   0x739F             STRB     R7,[R3, #+14]
    558              can_rx_msg->CAN_MsgTimeStamp  = time_stamp;
   \   00000066   0x8098             STRH     R0,[R3, #+4]
    559              memcpy(can_rx_msg->CAN_MsgDataBuffer,rx_data,data_length);
   \   00000068   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006A   0x003A             MOVS     R2,R7
   \   0000006C   0xA901             ADD      R1,SP,#+4
   \   0000006E   0x1D98             ADDS     R0,R3,#+6
   \   00000070   0x.... 0x....      BL       memcpy
    560               
    561              //读取自由计数器，解锁当前Msg缓冲区
    562              timer = LPLD_CAN_UnlockMsg(canx);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       LPLD_CAN_UnlockMsg
   \   0000007A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    563              //清空Msg缓冲区的中断标志位
    564              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
    565              //再次写邮箱的code为empty状态
    566              LPLD_CAN_SetMsgCode(canx,msg_num,CAN_MSGOBJ_RX_EMPTY);
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       LPLD_CAN_SetMsgCode
   \   00000094   0xE009             B.N      ??LPLD_CAN_ReceivedMessage_3
    567            }
    568            else
    569            {
    570              //接收邮箱溢出
    571              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_ReceivedMessage_0: (+1)
   \   00000096   0x0029             MOVS     R1,R5
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
    572              //读取自由计数器，解锁当前Msg缓冲区
    573              timer = LPLD_CAN_UnlockMsg(canx);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       LPLD_CAN_UnlockMsg
   \   000000A6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    574            }
    575          }
   \                     ??LPLD_CAN_ReceivedMessage_3: (+1)
   \   000000AA   0xB007             ADD      SP,SP,#+28
   \   000000AC   0xBDF0             POP      {R4-R7,PC}       ;; return
    576          
    577          /*
    578           * LPLD_CAN_Interrupt_ClearPending
    579           * 清除Msg的中断标志位
    580           * 参数:
    581           *    CAN_Type *canx
    582           *      |___ CAN0 --CAN0号模块
    583           *      |___ CAN1 --CAN1号模块
    584           *    msg_num 选择要清除中断标志的Msg缓冲区
    585           *      |___ MSG_NUM_0 --Msg缓冲区0
    586           *      |___ MSG_NUM_1 --Msg缓冲区1
    587           *      |___ MSG_NUM_2 --Msg缓冲区2
    588           *      |___ MSG_NUM_3 --Msg缓冲区3
    589           *      |___ MSG_NUM_4 --Msg缓冲区4
    590           *      ...... 
    591           *      |___ MSG_NUM_15 --Msg缓冲区15
    592           * 输出:
    593           *   无
    594           */

   \                                 In section .text, align 2, keep-with-next
    595          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *canx, uint8 msg_num)
    596          {   
    597            if(msg_num < 32)
   \                     LPLD_CAN_Interrupt_ClearPending: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA06             BGE.N    ??LPLD_CAN_Interrupt_ClearPending_0
    598            {
    599              canx->IFLAG1 |= (1<<msg_num); 
   \   00000006   0x6B02             LDR      R2,[R0, #+48]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000000E   0x4311             ORRS     R1,R1,R2
   \   00000010   0x6301             STR      R1,[R0, #+48]
   \   00000012   0xE006             B.N      ??LPLD_CAN_Interrupt_ClearPending_1
    600            }
    601            else
    602            {
    603              canx->IFLAG2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_Interrupt_ClearPending_0: (+1)
   \   00000014   0x6AC2             LDR      R2,[R0, #+44]
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x3920             SUBS     R1,R1,#+32
   \   0000001A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000001E   0x4311             ORRS     R1,R1,R2
   \   00000020   0x62C1             STR      R1,[R0, #+44]
    604            }
    605          }
   \                     ??LPLD_CAN_Interrupt_ClearPending_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    606          
    607          /*
    608           * LPLD_CAN_Interrupt_GetFlag
    609           * 获得CAN 的中断标志位
    610           * 参数:
    611           *    CAN_Type *canx
    612           *      |___ CAN0 --CAN0号模块
    613           *      |___ CAN1 --CAN1号模块
    614           *    msg_num 选择要获得中断标志的Msg缓冲区
    615           *      |___ MSG_NUM_0 --Msg缓冲区0
    616           *      |___ MSG_NUM_1 --Msg缓冲区1
    617           *      |___ MSG_NUM_2 --Msg缓冲区2
    618           *      |___ MSG_NUM_3 --Msg缓冲区3
    619           *      |___ MSG_NUM_4 --Msg缓冲区4
    620           *      ...... 
    621           *      |___ MSG_NUM_15 --Msg缓冲区15
    622           * 输出:
    623           *    返回需要 Msg缓冲区的中断标志位
    624           */

   \                                 In section .text, align 2, keep-with-next
    625          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *canx, uint8 msg_num)
    626          {   
    627            uint8 status;
    628            if(msg_num < 32)
   \                     LPLD_CAN_Interrupt_GetFlag: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA04             BGE.N    ??LPLD_CAN_Interrupt_GetFlag_0
    629            {
    630              status = (canx->IFLAG1 >> msg_num) & 0x01; 
   \   00000006   0x6B00             LDR      R0,[R0, #+48]
   \   00000008   0x40C8             LSRS     R0,R0,R1
   \   0000000A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000E   0xE004             B.N      ??LPLD_CAN_Interrupt_GetFlag_1
    631            }
    632            else
    633            {
    634              status = (canx->IFLAG2 >> (msg_num - 32) )& 0x01; 
   \                     ??LPLD_CAN_Interrupt_GetFlag_0: (+1)
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0x3920             SUBS     R1,R1,#+32
   \   00000014   0x40C8             LSRS     R0,R0,R1
   \   00000016   0xF010 0x0001      ANDS     R0,R0,#0x1
    635            }
    636            return status;
   \                     ??LPLD_CAN_Interrupt_GetFlag_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
    637          }
    638          
    639          /*
    640           * LPLD_CAN_UnlockMsg
    641           * 该函数通过读取自由计数器，解锁Msg
    642           * 参数:
    643           *    canx--设置CAN总线通道
    644           *      |__CAN0 --CAN0号模块
    645           *      |__CAN1 --CAN1号模块
    646           * 输出:
    647           *    16位CAN自由计数器记录的时间戳
    648           */

   \                                 In section .text, align 2, keep-with-next
    649          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *canx)
    650          {
    651            return (canx->TIMER);
   \                     LPLD_CAN_UnlockMsg: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /*
    655           * LPLD_CAN_EnableMsgInterrupt
    656           * 该函数用于使能Msg中断
    657           * 
    658           * 参数:
    659           *    canx--设置CAN总线通道
    660           *      |__CAN0 --CAN0号模块
    661           *      |__CAN1 --CAN1号模块
    662           *    msg_num 选择需要使能中断的Msg缓冲区
    663           *      |___ MSG_NUM_0 --Msg缓冲区0
    664           *      |___ MSG_NUM_1 --Msg缓冲区1
    665           *      |___ MSG_NUM_2 --Msg缓冲区2
    666           *      |___ MSG_NUM_3 --Msg缓冲区3
    667           *      |___ MSG_NUM_4 --Msg缓冲区4
    668           *      ...... 
    669           *      |___ MSG_NUM_15 --Msg缓冲区15
    670           * 输出:
    671           *    无
    672           *
    673           */

   \                                 In section .text, align 2, keep-with-next
    674          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *canx, uint8 msg_num)
    675          {
    676            if(msg_num < 32)
   \                     LPLD_CAN_EnableMsgInterrupt: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA06             BGE.N    ??LPLD_CAN_EnableMsgInterrupt_0
    677            {
    678              canx->IMASK1 |= (1<<msg_num); 
   \   00000006   0x6A82             LDR      R2,[R0, #+40]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000000E   0x4311             ORRS     R1,R1,R2
   \   00000010   0x6281             STR      R1,[R0, #+40]
   \   00000012   0xE006             B.N      ??LPLD_CAN_EnableMsgInterrupt_1
    679            }
    680            else
    681            {
    682              canx->IMASK2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_EnableMsgInterrupt_0: (+1)
   \   00000014   0x6A42             LDR      R2,[R0, #+36]
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x3920             SUBS     R1,R1,#+32
   \   0000001A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000001E   0x4311             ORRS     R1,R1,R2
   \   00000020   0x6241             STR      R1,[R0, #+36]
    683            }
    684          }
   \                     ??LPLD_CAN_EnableMsgInterrupt_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    685          
    686          /*
    687           * LPLD_CAN_SetMsgCode
    688           * 该函数用于设置Msg的code值
    689           * 
    690           * 参数:
    691           *    canx--设置CAN总线通道
    692           *      |__CAN0 --CAN0号模块
    693           *      |__CAN1 --CAN1号模块
    694           *    msg_num 选择需要设置CODE的Msg缓冲区
    695           *      |___ MSG_NUM_0 --Msg缓冲区0
    696           *      |___ MSG_NUM_1 --Msg缓冲区1
    697           *      |___ MSG_NUM_2 --Msg缓冲区2
    698           *      |___ MSG_NUM_3 --Msg缓冲区3
    699           *      |___ MSG_NUM_4 --Msg缓冲区4
    700           *      ...... 
    701           *      |___ MSG_NUM_15 --Msg缓冲区15
    702           *    code--需要设置的code值
    703           * 输出:
    704           *    无
    705           *
    706           */

   \                                 In section .text, align 2, keep-with-next
    707          static void LPLD_CAN_SetMsgCode(CAN_Type *canx, uint8 msg_num, uint8 code)
    708          {
    709            //canx->MB[msg_num].CS &= (~CAN_MB_CS_CODE_MASK);
    710            canx->MB[msg_num].CS |= CAN_MB_CS_CODE(code);
   \                     LPLD_CAN_SetMsgCode: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000006   0xF8D3 0x3080      LDR      R3,[R3, #+128]
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0612             LSLS     R2,R2,#+24
   \   0000000E   0xF012 0x6270      ANDS     R2,R2,#0xF000000
   \   00000012   0x431A             ORRS     R2,R2,R3
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   0000001A   0xF8C0 0x2080      STR      R2,[R0, #+128]
    711          }
   \   0000001E   0x4770             BX       LR               ;; return
    712          
    713          /*
    714           * LPLD_CAN_GetMsgCode
    715           * 该函数用于获得Msg缓冲区的code值
    716           * 
    717           * 参数:
    718           *    canx--设置CAN总线通道
    719           *      |__CAN0 --CAN0号模块
    720           *      |__CAN1 --CAN1号模块
    721           *    msg_num 选择需要获得CODE的Msg缓冲区
    722           *      |___ MSG_NUM_0 --Msg缓冲区0
    723           *      |___ MSG_NUM_1 --Msg缓冲区1
    724           *      |___ MSG_NUM_2 --Msg缓冲区2
    725           *      |___ MSG_NUM_3 --Msg缓冲区3
    726           *      |___ MSG_NUM_4 --Msg缓冲区4
    727           *      ...... 
    728           *      |___ MSG_NUM_15 --Msg缓冲区15
    729           * 输出:
    730           *     返回相应Msg缓冲区的code
    731           *
    732           */

   \                                 In section .text, align 2, keep-with-next
    733          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *canx, uint8 msg_num)
    734          {
    735             return CAN_GET_MB_CS_CODE(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgCode: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \   0000000E   0x4770             BX       LR               ;; return
    736          }
    737          /*
    738           * LPLD_CAN_GetMsgTimeStamp
    739           * 该函数用于获得Msg缓冲区的时间戳
    740           * 
    741           * 参数:
    742           *    canx--设置CAN总线通道
    743           *      |__CAN0 --CAN0号模块
    744           *      |__CAN1 --CAN1号模块
    745           *    msg_num 选择需要获得时间戳的Msg缓冲区
    746           *      |___ MSG_NUM_0 --Msg缓冲区0
    747           *      |___ MSG_NUM_1 --Msg缓冲区1
    748           *      |___ MSG_NUM_2 --Msg缓冲区2
    749           *      |___ MSG_NUM_3 --Msg缓冲区3
    750           *      |___ MSG_NUM_4 --Msg缓冲区4
    751           *      ...... 
    752           *      |___ MSG_NUM_15 --Msg缓冲区15
    753           * 输出:
    754           *     返回相应Msg缓冲区的时间戳
    755           *
    756           */

   \                                 In section .text, align 2, keep-with-next
    757          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *canx, uint8 msg_num)
    758          {
    759            return CAN_GET_MB_CS_TIMESTAMP(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgTimeStamp: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    760          }
    761          
    762          /*
    763           * LPLD_CAN_SetMsgID
    764           * 该函数用于设置Msg缓冲区的ID值
    765           * 
    766           * 参数:
    767           *    canx--设置CAN总线通道
    768           *      |__CAN0 --CAN0号模块
    769           *      |__CAN1 --CAN1号模块
    770           *    msg_num 选择需要设置ID的Msg缓冲区
    771           *      |___ MSG_NUM_0 --Msg缓冲区0
    772           *      |___ MSG_NUM_1 --Msg缓冲区1
    773           *      |___ MSG_NUM_2 --Msg缓冲区2
    774           *      |___ MSG_NUM_3 --Msg缓冲区3
    775           *      |___ MSG_NUM_4 --Msg缓冲区4
    776           *      ...... 
    777           *      |___ MSG_NUM_15 --Msg缓冲区15
    778           *   message_id
    779           *      |__设置Msg缓冲区的ID
    780           * 输出：
    781           *   无
    782           */

   \                                 In section .text, align 2, keep-with-next
    783          static void LPLD_CAN_SetMsgID(CAN_Type *canx, uint8 msg_num,uint32 message_id)
    784          {
    785            uint32 id_temp;
    786            if(CAN_GET_MB_CS_IDE(canx->MB[msg_num].CS) == CAN_MSGOBJ_ID_STD)
   \                     LPLD_CAN_SetMsgID: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000006   0xF8D3 0x3080      LDR      R3,[R3, #+128]
   \   0000000A   0xF3C3 0x5340      UBFX     R3,R3,#+21,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD104             BNE.N    ??LPLD_CAN_SetMsgID_0
    787            {
    788              id_temp =  CAN_MB_ID_STD(message_id);
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable12_24  ;; 0x1ffc0000
   \   00000016   0xEA13 0x4282      ANDS     R2,R3,R2, LSL #+18
   \   0000001A   0xE001             B.N      ??LPLD_CAN_SetMsgID_1
    789            }
    790            else
    791            {
    792              id_temp =  CAN_MB_ID_EXT(message_id);
   \                     ??LPLD_CAN_SetMsgID_0: (+1)
   \   0000001C   0x00D2             LSLS     R2,R2,#+3        ;; ZeroExtS R2,R2,#+3,#+3
   \   0000001E   0x08D2             LSRS     R2,R2,#+3
    793            }
    794            canx->MB[msg_num].ID = id_temp;
   \                     ??LPLD_CAN_SetMsgID_1: (+1)
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000026   0xF8C0 0x2084      STR      R2,[R0, #+132]
    795          }
   \   0000002A   0x4770             BX       LR               ;; return
    796          
    797          /*
    798           * LPLD_CAN_GetMsgID
    799           * 该函数用于获得Msg缓冲区的ID值
    800           * 
    801           * 参数:
    802           *    canx--设置CAN总线通道
    803           *      |__CAN0 --CAN0号模块
    804           *      |__CAN1 --CAN1号模块
    805           *    msg_num 选择需要获得ID的Msg缓冲区
    806           *      |___ MSG_NUM_0 --Msg缓冲区0
    807           *      |___ MSG_NUM_1 --Msg缓冲区1
    808           *      |___ MSG_NUM_2 --Msg缓冲区2
    809           *      |___ MSG_NUM_3 --Msg缓冲区3
    810           *      |___ MSG_NUM_4 --Msg缓冲区4
    811           *      ...... 
    812           *      |___ MSG_NUM_15 --Msg缓冲区15
    813           * 输出:
    814           *     返回相应Msg缓冲区的ID
    815           *
    816           */

   \                                 In section .text, align 2, keep-with-next
    817          static uint32 LPLD_CAN_GetMsgID(CAN_Type *canx, uint8 msg_num)
    818          {
    819            uint32 id_temp;
    820            if(CAN_GET_MB_CS_IDE(canx->MB[msg_num].CS) == CAN_MSGOBJ_ID_STD)
   \                     LPLD_CAN_GetMsgID: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1201      ADDS     R2,R0,R1, LSL #+4
   \   00000006   0xF8D2 0x2080      LDR      R2,[R2, #+128]
   \   0000000A   0xF3C2 0x5240      UBFX     R2,R2,#+21,#+1
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD107             BNE.N    ??LPLD_CAN_GetMsgID_0
    821            {
    822              id_temp =  CAN_GET_MB_ID_STD(canx->MB[msg_num].ID);
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000018   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000001C   0xF3C0 0x408A      UBFX     R0,R0,#+18,#+11
   \   00000020   0xE006             B.N      ??LPLD_CAN_GetMsgID_1
    823            }
    824            else
    825            {
    826              id_temp =  CAN_GET_MB_ID_EXT(canx->MB[msg_num].ID);
   \                     ??LPLD_CAN_GetMsgID_0: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000028   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000002C   0x00C0             LSLS     R0,R0,#+3        ;; ZeroExtS R0,R0,#+3,#+3
   \   0000002E   0x08C0             LSRS     R0,R0,#+3
    827            }
    828            return id_temp;
   \                     ??LPLD_CAN_GetMsgID_1: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    829          }
    830          
    831          /*
    832           * LPLD_CAN_SetMsgLength
    833           * 该函数用于设置Msg缓冲区的数据长度
    834           * 
    835           * 参数:
    836           *    canx--设置CAN总线通道
    837           *      |__CAN0 --CAN0号模块
    838           *      |__CAN1 --CAN1号模块
    839           *    msg_num 选择需要设置数据长度的Msg缓冲区
    840           *      |___ MSG_NUM_0 --Msg缓冲区0
    841           *      |___ MSG_NUM_1 --Msg缓冲区1
    842           *      |___ MSG_NUM_2 --Msg缓冲区2
    843           *      |___ MSG_NUM_3 --Msg缓冲区3
    844           *      |___ MSG_NUM_4 --Msg缓冲区4
    845           *      ...... 
    846           *      |___ MSG_NUM_15 --Msg缓冲区15
    847           *   in_length
    848           *      |__数据长度
    849           * 输出:
    850           *     无
    851           *
    852           */

   \                                 In section .text, align 2, keep-with-next
    853          static void LPLD_CAN_SetMsgLength(CAN_Type *canx, uint8 msg_num,uint8 in_length)
    854          {
    855            //canx->MB[msg_num].CS &= (~CAN_MB_CS_DLC_MASK);
    856            canx->MB[msg_num].CS |= CAN_MB_CS_DLC(in_length);  
   \                     LPLD_CAN_SetMsgLength: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000006   0xF8D3 0x3080      LDR      R3,[R3, #+128]
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0412             LSLS     R2,R2,#+16
   \   0000000E   0xF412 0x2270      ANDS     R2,R2,#0xF0000
   \   00000012   0x431A             ORRS     R2,R2,R3
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   0000001A   0xF8C0 0x2080      STR      R2,[R0, #+128]
    857          }
   \   0000001E   0x4770             BX       LR               ;; return
    858          
    859          /*
    860           * LPLD_CAN_GetMsgLength
    861           * 该函数用于获得Msg缓冲区的数据长度
    862           * 
    863           * 参数:
    864           *    canx--设置CAN总线通道
    865           *      |__CAN0 --CAN0号模块
    866           *      |__CAN1 --CAN1号模块
    867           *    msg_num 选择需要获得数据长度的Msg缓冲区
    868           *      |___ MSG_NUM_0 --Msg缓冲区0
    869           *      |___ MSG_NUM_1 --Msg缓冲区1
    870           *      |___ MSG_NUM_2 --Msg缓冲区2
    871           *      |___ MSG_NUM_3 --Msg缓冲区3
    872           *      |___ MSG_NUM_4 --Msg缓冲区4
    873           *      ...... 
    874           *      |___ MSG_NUM_15 --Msg缓冲区15
    875           * 输出:
    876           *     数据的长度
    877           *
    878           */

   \                                 In section .text, align 2, keep-with-next
    879          static uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 msg_num)
    880          {
    881            return CAN_GET_MB_CS_LENGTH(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgLength: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000010   0x4770             BX       LR               ;; return
    882          }
    883          
    884          /*
    885           * LPLD_CAN_GetData
    886           * 该函数用于获得Msg缓冲区中的数据
    887           * 
    888           * 参数:
    889           *    canx--设置CAN总线通道
    890           *      |__CAN0 --CAN0号模块
    891           *      |__CAN1 --CAN1号模块
    892           *    msg_num 选择需要获得数据的Msg缓冲区
    893           *      |___ MSG_NUM_0 --Msg缓冲区0
    894           *      |___ MSG_NUM_1 --Msg缓冲区1
    895           *      |___ MSG_NUM_2 --Msg缓冲区2
    896           *      |___ MSG_NUM_3 --Msg缓冲区3
    897           *      |___ MSG_NUM_4 --Msg缓冲区4
    898           *      ...... 
    899           *      |___ MSG_NUM_15 --Msg缓冲区15
    900           *    in_length
    901           *      |__获得数据长度
    902           *    *in_buffer
    903           *      |__获得数据的缓冲区
    904           * 输出:
    905           *    无 
    906           */

   \                                 In section .text, align 2, keep-with-next
    907          static void LPLD_CAN_GetData(
    908              CAN_Type *canx, 
    909              uint8     msg_num, 
    910              uint8     in_length, 
    911              uint8    *in_buffer)
    912          {
   \                     LPLD_CAN_GetData: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    913            int i;
    914            uint8  *pMBData;
    915            uint8  *pRecieve  = in_buffer;
    916            uint8  word_num   = (in_length - 1)/ 4; //Get the Message buffer word number
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x1E54             SUBS     R4,R2,#+1
   \   00000006   0x2504             MOVS     R5,#+4
   \   00000008   0xFB94 0xF4F5      SDIV     R4,R4,R5
    917            uint8  rest_bytes = (in_length - 1)% 4; //Get the reset bytes of buffer
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x1E55             SUBS     R5,R2,#+1
   \   00000010   0x2604             MOVS     R6,#+4
   \   00000012   0xFB95 0xF2F6      SDIV     R2,R5,R6
   \   00000016   0xFB02 0x5216      MLS      R2,R2,R6,R5
    918            if(word_num > 0)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD012             BEQ.N    ??LPLD_CAN_GetData_0
    919            {  
    920              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0xEB10 0x1501      ADDS     R5,R0,R1, LSL #+4
   \   00000026   0xF115 0x068B      ADDS     R6,R5,#+139
    921              for(i = 0 ; i < 4 ; i++)   
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0xE003             B.N      ??LPLD_CAN_GetData_1
    922              {
    923                pRecieve[i] = *pMBData--;
   \                     ??LPLD_CAN_GetData_2: (+1)
   \   0000002E   0x7837             LDRB     R7,[R6, #+0]
   \   00000030   0x54EF             STRB     R7,[R5, R3]
   \   00000032   0x1E76             SUBS     R6,R6,#+1
    924              }
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_GetData_1: (+1)
   \   00000036   0x2D04             CMP      R5,#+4
   \   00000038   0xDBF9             BLT.N    ??LPLD_CAN_GetData_2
    925              pMBData = (uint8*)&canx->MB[msg_num].WORD1+3;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   00000040   0xF110 0x068F      ADDS     R6,R0,#+143
   \   00000044   0xE004             B.N      ??LPLD_CAN_GetData_3
    926            }
    927            else
    928            {
    929              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \                     ??LPLD_CAN_GetData_0: (+1)
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   0000004C   0xF110 0x068B      ADDS     R6,R0,#+139
    930            }
    931          
    932            for(i = 0; i <= rest_bytes; i++)
   \                     ??LPLD_CAN_GetData_3: (+1)
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0xE006             B.N      ??LPLD_CAN_GetData_4
    933            {
    934              pRecieve[i+(word_num<<2)] = *pMBData--;    
   \                     ??LPLD_CAN_GetData_5: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xEB15 0x0084      ADDS     R0,R5,R4, LSL #+2
   \   0000005A   0x7831             LDRB     R1,[R6, #+0]
   \   0000005C   0x54C1             STRB     R1,[R0, R3]
   \   0000005E   0x1E76             SUBS     R6,R6,#+1
    935            }
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_GetData_4: (+1)
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x42AA             CMP      R2,R5
   \   00000066   0xDAF5             BGE.N    ??LPLD_CAN_GetData_5
    936          }
   \   00000068   0xBCF0             POP      {R4-R7}
   \   0000006A   0x4770             BX       LR               ;; return
    937          
    938          /*
    939           * LPLD_CAN_WriteData
    940           * 该函数用于向Msg缓冲区中的写数据
    941           * 
    942           * 参数:
    943           *    canx--设置CAN总线通道
    944           *      |__CAN0 --CAN0号模块
    945           *      |__CAN1 --CAN1号模块
    946           *    msg_num 选择需要写数据的Msg缓冲区
    947           *      |___ MSG_NUM_0 --Msg缓冲区0
    948           *      |___ MSG_NUM_1 --Msg缓冲区1
    949           *      |___ MSG_NUM_2 --Msg缓冲区2
    950           *      |___ MSG_NUM_3 --Msg缓冲区3
    951           *      |___ MSG_NUM_4 --Msg缓冲区4
    952           *      ...... 
    953           *      |___ MSG_NUM_15 --Msg缓冲区15
    954           *    in_length
    955           *      |__写入数据长度
    956           *    *in_buffer
    957           *      |__写入数据的缓冲区
    958           * 输出:
    959           *    无 
    960           */

   \                                 In section .text, align 2, keep-with-next
    961          static void LPLD_CAN_WriteData(
    962              CAN_Type *canx, 
    963              uint8     msg_num, 
    964              uint8     in_length, 
    965              uint8    *in_buffer )
    966          {
   \                     LPLD_CAN_WriteData: (+1)
   \   00000000   0xB4FC             PUSH     {R2-R7}
    967            int i;
    968            uint32 word[2] = {0};  
   \   00000002   0xAC00             ADD      R4,SP,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xC460             STM      R4!,{R5,R6}
   \   0000000A   0x3C08             SUBS     R4,R4,#+8
    969            uint8  word_num   = (in_length - 1)/ 4; //获得 Msg 的Word 值
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x1E54             SUBS     R4,R2,#+1
   \   00000010   0x2504             MOVS     R5,#+4
   \   00000012   0xFB94 0xF4F5      SDIV     R4,R4,R5
    970            uint8  rest_bytes = (in_length - 1)% 4; //获得剩余字节的值
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x1E55             SUBS     R5,R2,#+1
   \   0000001A   0x2604             MOVS     R6,#+4
   \   0000001C   0xFB95 0xF2F6      SDIV     R2,R5,R6
   \   00000020   0xFB02 0x5216      MLS      R2,R2,R6,R5
    971          
    972            if(word_num < 1)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD115             BNE.N    ??LPLD_CAN_WriteData_0
    973            {
    974              for (i = 0; i <= rest_bytes ; i++)
   \   0000002A   0x2500             MOVS     R5,#+0
   \                     ??LPLD_CAN_WriteData_1: (+1)
   \   0000002C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002E   0x42AA             CMP      R2,R5
   \   00000030   0xDB41             BLT.N    ??LPLD_CAN_WriteData_2
    975              {
    976                word[word_num] |=  (uint32)in_buffer[i] << (24-(i<<3));
   \   00000032   0xAE00             ADD      R6,SP,#+0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0xF856 0x6024      LDR      R6,[R6, R4, LSL #+2]
   \   0000003A   0x5CEF             LDRB     R7,[R5, R3]
   \   0000003C   0xEA5F 0x0CC5      LSLS     R12,R5,#+3
   \   00000040   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   00000044   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000048   0x433E             ORRS     R6,R7,R6
   \   0000004A   0xAF00             ADD      R7,SP,#+0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0xF847 0x6024      STR      R6,[R7, R4, LSL #+2]
    977              }
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
   \   00000054   0xE7EA             B.N      ??LPLD_CAN_WriteData_1
    978            }
    979            else
    980            {
    981              for (i = 0; i < 4; i++)
   \                     ??LPLD_CAN_WriteData_0: (+1)
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0xE014             B.N      ??LPLD_CAN_WriteData_3
    982              {
    983                word[word_num-1] |= (uint32)in_buffer[i] << (24-(i<<3));
   \                     ??LPLD_CAN_WriteData_4: (+1)
   \   0000005A   0xAE00             ADD      R6,SP,#+0
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0xEB16 0x0684      ADDS     R6,R6,R4, LSL #+2
   \   00000062   0xF856 0x6C04      LDR      R6,[R6, #-4]
   \   00000066   0x5CEF             LDRB     R7,[R5, R3]
   \   00000068   0xEA5F 0x0CC5      LSLS     R12,R5,#+3
   \   0000006C   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   00000070   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000074   0x433E             ORRS     R6,R7,R6
   \   00000076   0xAF00             ADD      R7,SP,#+0
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0xEB17 0x0784      ADDS     R7,R7,R4, LSL #+2
   \   0000007E   0xF847 0x6C04      STR      R6,[R7, #-4]
    984              }
   \   00000082   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_WriteData_3: (+1)
   \   00000084   0x2D04             CMP      R5,#+4
   \   00000086   0xDBE8             BLT.N    ??LPLD_CAN_WriteData_4
    985              for (i = 0; i <= rest_bytes ; i++)
   \   00000088   0x2500             MOVS     R5,#+0
   \   0000008A   0xE011             B.N      ??LPLD_CAN_WriteData_5
    986              {
    987                word[word_num] |=  (uint32)in_buffer[i+4] << (24-(i<<3));
   \                     ??LPLD_CAN_WriteData_6: (+1)
   \   0000008C   0xAE00             ADD      R6,SP,#+0
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0xF856 0x6024      LDR      R6,[R6, R4, LSL #+2]
   \   00000094   0x18EF             ADDS     R7,R5,R3
   \   00000096   0x793F             LDRB     R7,[R7, #+4]
   \   00000098   0xEA5F 0x0CC5      LSLS     R12,R5,#+3
   \   0000009C   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   000000A0   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   000000A4   0x433E             ORRS     R6,R7,R6
   \   000000A6   0xAF00             ADD      R7,SP,#+0
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0xF847 0x6024      STR      R6,[R7, R4, LSL #+2]
    988              }
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_WriteData_5: (+1)
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x42AA             CMP      R2,R5
   \   000000B4   0xDAEA             BGE.N    ??LPLD_CAN_WriteData_6
    989            }
    990            canx->MB[msg_num].WORD0 = word[0];
   \                     ??LPLD_CAN_WriteData_2: (+1)
   \   000000B6   0x9A00             LDR      R2,[SP, #+0]
   \   000000B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BA   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000BE   0xF8C3 0x2088      STR      R2,[R3, #+136]
    991            canx->MB[msg_num].WORD1 = word[1];
   \   000000C2   0x9A01             LDR      R2,[SP, #+4]
   \   000000C4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C6   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \   000000CA   0xF8C0 0x208C      STR      R2,[R0, #+140]
    992          }
   \   000000CE   0xBCF3             POP      {R0,R1,R4-R7}
   \   000000D0   0x4770             BX       LR               ;; return
    993          
    994          /*
    995           * LPLD_CAN_Transmit_Interrupt
    996           * 该函数用于处理Msg缓冲区发送中断函数
    997           * 
    998           * 参数:
    999           *    canx--设置CAN总线通道
   1000           *      |__CAN0 --CAN0号模块
   1001           *      |__CAN1 --CAN1号模块
   1002           *    msg_num 选择需要处理发送中断的Msg缓冲区
   1003           *      |___ MSG_NUM_0 --Msg缓冲区0
   1004           *      |___ MSG_NUM_1 --Msg缓冲区1
   1005           *      |___ MSG_NUM_2 --Msg缓冲区2
   1006           *      |___ MSG_NUM_3 --Msg缓冲区3
   1007           *      |___ MSG_NUM_4 --Msg缓冲区4
   1008           *      ...... 
   1009           *      |___ MSG_NUM_15 --Msg缓冲区15
   1010           * 输出:
   1011           *    无 
   1012           */

   \                                 In section .text, align 2, keep-with-next
   1013          static void LPLD_CAN_Transmit_Interrupt(CAN_Type *canx, uint8 msg_num)
   1014          {
   \                     LPLD_CAN_Transmit_Interrupt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1015            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num))
   \   00000006   0x0021             MOVS     R1,R4
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       LPLD_CAN_Interrupt_GetFlag
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD012             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
   1016            {
   1017             LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
   1018             if(canx == CAN0)
   \   0000001E   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40024000
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD10B             BNE.N    ??LPLD_CAN_Transmit_Interrupt_1
   1019             {
   1020              if( CAN0_ISR[msg_num] != NULL)
   \   00000024   0x....             LDR.N    R0,??DataTable12_22
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD004             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
   1021              {
   1022                CAN0_ISR[msg_num]();
   \   00000030   0x....             LDR.N    R0,??DataTable12_22
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000038   0x4780             BLX      R0
   1023              }
   1024             }
   1025             else if (canx == CAN1)
   1026             {
   1027              if( CAN1_ISR[msg_num] != NULL)
   1028              {
   1029                CAN1_ISR[msg_num]();
   1030              }
   1031             }
   1032             else
   1033             {
   1034                return;
   1035             }
   1036            }
   1037          }
   \                     ??LPLD_CAN_Transmit_Interrupt_0: (+1)
   \                     ??LPLD_CAN_Transmit_Interrupt_2: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??LPLD_CAN_Transmit_Interrupt_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable12_21  ;; 0x400a4000
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD10B             BNE.N    ??LPLD_CAN_Transmit_Interrupt_3
   \   00000042   0x....             LDR.N    R0,??DataTable12_23
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0F5             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
   \   0000004E   0x....             LDR.N    R0,??DataTable12_23
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0x4780             BLX      R0
   \   00000058   0xE7EF             B.N      ??LPLD_CAN_Transmit_Interrupt_0
   \                     ??LPLD_CAN_Transmit_Interrupt_3: (+1)
   \   0000005A   0xE7EE             B.N      ??LPLD_CAN_Transmit_Interrupt_2
   1038          
   1039          /*
   1040           * LPLD_CAN_Receive_Interrupt
   1041           * 该函数用于处理Msg缓冲区接收中断函数
   1042           * 
   1043           * 参数:
   1044           *    canx--设置CAN总线通道
   1045           *      |__CAN0 --CAN0号模块
   1046           *      |__CAN1 --CAN1号模块
   1047           *    msg_num 选择需要处理接收中断的Msg缓冲区
   1048           *      |___ MSG_NUM_0 --Msg缓冲区0
   1049           *      |___ MSG_NUM_1 --Msg缓冲区1
   1050           *      |___ MSG_NUM_2 --Msg缓冲区2
   1051           *      |___ MSG_NUM_3 --Msg缓冲区3
   1052           *      |___ MSG_NUM_4 --Msg缓冲区4
   1053           *      ...... 
   1054           *      |___ MSG_NUM_15 --Msg缓冲区15
   1055           * 输出:
   1056           *    无 
   1057           */

   \                                 In section .text, align 2, keep-with-next
   1058          static void LPLD_CAN_Receive_Interrupt(CAN_Type *canx, uint8 msg_num)
   1059          {
   \                     LPLD_CAN_Receive_Interrupt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1060            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num))
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       LPLD_CAN_Interrupt_GetFlag
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD012             BEQ.N    ??LPLD_CAN_Receive_Interrupt_0
   1061            {
   1062              //如果定义了中断回掉函数，在此执行
   1063              if(canx == CAN0)
   \   00000014   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40024000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD110             BNE.N    ??LPLD_CAN_Receive_Interrupt_1
   1064              {
   1065                if( CAN0_ISR[msg_num] != NULL)
   \   0000001A   0x....             LDR.N    R0,??DataTable12_22
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   1066                {
   1067                    CAN0_ISR[msg_num]();
   \   00000026   0x....             LDR.N    R0,??DataTable12_22
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000002E   0x4780             BLX      R0
   1068                }
   1069              }
   1070              else if (canx == CAN1)
   1071              {
   1072                if( CAN1_ISR[msg_num] != NULL)
   1073                {
   1074                    CAN1_ISR[msg_num]();
   1075                }
   1076              }
   1077              else
   1078              {
   1079                return;
   1080              }
   1081              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_Receive_Interrupt_2: (+1)
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
   1082            }
   1083          }
   \                     ??LPLD_CAN_Receive_Interrupt_0: (+1)
   \                     ??LPLD_CAN_Receive_Interrupt_3: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??LPLD_CAN_Receive_Interrupt_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable12_21  ;; 0x400a4000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD10B             BNE.N    ??LPLD_CAN_Receive_Interrupt_4
   \   00000042   0x....             LDR.N    R0,??DataTable12_23
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0F0             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   \   0000004E   0x....             LDR.N    R0,??DataTable12_23
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000056   0x4780             BLX      R0
   \   00000058   0xE7EA             B.N      ??LPLD_CAN_Receive_Interrupt_2
   \                     ??LPLD_CAN_Receive_Interrupt_4: (+1)
   \   0000005A   0xE7EE             B.N      ??LPLD_CAN_Receive_Interrupt_3
   1084          
   1085          /*
   1086           * LPLD_CAN_CAN0_Interrupt_Handler
   1087           * CAN0中断处理函数
   1088           * 
   1089           * 参数:
   1090           *    CAN_MSGOBJ_InitTypeDef *CAN_MSGOBJ_Ptr
   1091           *                           轮询检查16个Msg的结构体
   1092           * 输出:
   1093           *    无 
   1094           */

   \                                 In section .text, align 2, keep-with-next
   1095          static void LPLD_CAN_CAN0_Interrupt_Handler(CAN_MSGOBJ_InitTypeDef *CAN_MSGOBJ_Ptr)
   1096          {
   \                     LPLD_CAN_CAN0_Interrupt_Handler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1097            uint8 msg_obj;
   1098            uint8 direction;
   1099            CAN_Type *canx_ptr;
   1100          
   1101            for (msg_obj = 0; msg_obj < MSG_MAX_NO; msg_obj++)
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE007             B.N      ??LPLD_CAN_CAN0_Interrupt_Handler_0
   1102            {
   1103              canx_ptr  = (CAN_MSGOBJ_Ptr + msg_obj)->CAN_Canx;
   1104              direction = (CAN_MSGOBJ_Ptr + msg_obj)->CAN_MsgDirection;
   1105              if(direction == CAN_MSGOBJ_DIR_TX)
   1106              {
   1107                LPLD_CAN_Transmit_Interrupt(canx_ptr,msg_obj);
   1108              }
   1109              else if(direction == CAN_MSGOBJ_DIR_RX)
   \                     ??LPLD_CAN_CAN0_Interrupt_Handler_1: (+1)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD103             BNE.N    ??LPLD_CAN_CAN0_Interrupt_Handler_2
   1110              {
   1111                LPLD_CAN_Receive_Interrupt(canx_ptr,msg_obj);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x.... 0x....      BL       LPLD_CAN_Receive_Interrupt
   1112              }
   \                     ??LPLD_CAN_CAN0_Interrupt_Handler_2: (+1)
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_CAN0_Interrupt_Handler_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D10             CMP      R5,#+16
   \   0000001C   0xDA0E             BGE.N    ??LPLD_CAN_CAN0_Interrupt_Handler_3
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x0128             LSLS     R0,R5,#+4
   \   00000022   0x5900             LDR      R0,[R0, R4]
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0xEB14 0x1105      ADDS     R1,R4,R5, LSL #+4
   \   0000002A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2902             CMP      R1,#+2
   \   00000030   0xD1EA             BNE.N    ??LPLD_CAN_CAN0_Interrupt_Handler_1
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x.... 0x....      BL       LPLD_CAN_Transmit_Interrupt
   \   0000003A   0xE7EC             B.N      ??LPLD_CAN_CAN0_Interrupt_Handler_2
   1113            }
   1114          }
   \                     ??LPLD_CAN_CAN0_Interrupt_Handler_3: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1115          
   1116          /*
   1117           *  LPLD_CAN_CAN1_Interrupt_Handler
   1118           *  CAN1中断处理函数
   1119           * 
   1120           * 参数:
   1121           *    CAN_MSGOBJ_InitTypeDef *CAN_MSGOBJ_Ptr
   1122           *                           轮询检查16个Msg的结构体
   1123           * 输出:
   1124           *    无 
   1125           */

   \                                 In section .text, align 2, keep-with-next
   1126          static void LPLD_CAN_CAN1_Interrupt_Handler(CAN_MSGOBJ_InitTypeDef *CAN_MSGOBJ_Ptr)
   1127          {
   \                     LPLD_CAN_CAN1_Interrupt_Handler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1128            uint8 msg_obj;
   1129            uint8 direction;
   1130            CAN_Type *canx_ptr;
   1131          
   1132            for (msg_obj = 0; msg_obj < MSG_MAX_NO; msg_obj++)
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE007             B.N      ??LPLD_CAN_CAN1_Interrupt_Handler_0
   1133            {
   1134              canx_ptr  = (CAN_MSGOBJ_Ptr + msg_obj)->CAN_Canx;
   1135              direction = (CAN_MSGOBJ_Ptr + msg_obj)->CAN_MsgDirection;
   1136          
   1137              if(direction == CAN_MSGOBJ_DIR_TX)
   1138              {
   1139                LPLD_CAN_Transmit_Interrupt(canx_ptr,msg_obj);
   1140              }
   1141              else if(direction == CAN_MSGOBJ_DIR_RX)
   \                     ??LPLD_CAN_CAN1_Interrupt_Handler_1: (+1)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD103             BNE.N    ??LPLD_CAN_CAN1_Interrupt_Handler_2
   1142              {
   1143                LPLD_CAN_Receive_Interrupt(canx_ptr,msg_obj);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x.... 0x....      BL       LPLD_CAN_Receive_Interrupt
   1144              }
   \                     ??LPLD_CAN_CAN1_Interrupt_Handler_2: (+1)
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_CAN1_Interrupt_Handler_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D10             CMP      R5,#+16
   \   0000001C   0xDA0E             BGE.N    ??LPLD_CAN_CAN1_Interrupt_Handler_3
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x0128             LSLS     R0,R5,#+4
   \   00000022   0x5900             LDR      R0,[R0, R4]
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0xEB14 0x1105      ADDS     R1,R4,R5, LSL #+4
   \   0000002A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2902             CMP      R1,#+2
   \   00000030   0xD1EA             BNE.N    ??LPLD_CAN_CAN1_Interrupt_Handler_1
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x.... 0x....      BL       LPLD_CAN_Transmit_Interrupt
   \   0000003A   0xE7EC             B.N      ??LPLD_CAN_CAN1_Interrupt_Handler_2
   1145            }
   1146          }
   \                     ??LPLD_CAN_CAN1_Interrupt_Handler_3: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1147          
   1148          /*
   1149           * CAN0中断处理函数
   1150           * 与启动文件startup_K60.s中的中断向量表关联
   1151           * 用户无需修改，程序自动进入对应通道中断函数
   1152           */

   \                                 In section .text, align 2, keep-with-next
   1153          void CAN0_MESS_IRQHandler(void)
   1154          {
   \                     CAN0_MESS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1155          #if (UCOS_II > 0u)
   1156            OS_CPU_SR  cpu_sr = 0u;
   1157            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1158            OSIntEnter();
   1159            OS_EXIT_CRITICAL();
   1160          #endif
   1161            LPLD_CAN_CAN0_Interrupt_Handler(flexcan_msgobj_param_t);
   \   00000002   0x....             LDR.N    R0,??DataTable12_25
   \   00000004   0x.... 0x....      BL       LPLD_CAN_CAN0_Interrupt_Handler
   1162          #if (UCOS_II > 0u)
   1163            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1164          #endif
   1165          }      
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1166          //29:  CAM 0 OR'ed Message buffer (0-15)
   1167          

   \                                 In section .text, align 2, keep-with-next
   1168          void CAN0_BUS_OFF_IRQHandler(void){}   //30:  CAM 0 Bus Off
   \                     CAN0_BUS_OFF_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1169          void CAN0_ERR_IRQHandler(void){}       //31:  CAM 0 Error
   \                     CAN0_ERR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1170          void CAN0_TW_IRQHandler(void){}        //32:  CAM 0 Transmit Warning
   \                     CAN0_TW_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1171          void CAN0_RW_IRQHandler(void){}        //33:  CAM 0 Receive Warning
   \                     CAN0_RW_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1172          void CAN0_WAKE_UP_IRQHandler(void){}   //34:  CAM 0 WakeUp
   \                     CAN0_WAKE_UP_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1173          void CAN0_IMEU_IRQHandler(void){}      //35:  CAM 0 Individual Matching Elements Update (IMEU)
   \                     CAN0_IMEU_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1174          void CAN0_LR_IRQHandler(void){}        //36:  CAM 0 Lost receive
   \                     CAN0_LR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1175          
   1176          /*
   1177           * CAN1中断处理函数
   1178           * 与启动文件startup_K60.s中的中断向量表关联
   1179           * 用户无需修改，程序自动进入对应通道中断函数
   1180           */

   \                                 In section .text, align 2, keep-with-next
   1181          void CAN1_MESS_IRQHandler(void)
   1182          {
   \                     CAN1_MESS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1183          #if (UCOS_II > 0u)
   1184            OS_CPU_SR  cpu_sr = 0u;
   1185            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1186            OSIntEnter();
   1187            OS_EXIT_CRITICAL();
   1188          #endif
   1189            LPLD_CAN_CAN1_Interrupt_Handler(flexcan_msgobj_param_t);
   \   00000002   0x....             LDR.N    R0,??DataTable12_25
   \   00000004   0x.... 0x....      BL       LPLD_CAN_CAN1_Interrupt_Handler
   1190          #if (UCOS_II > 0u)
   1191            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1192          #endif
   1193          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1194          //37:  CAM 1 OR'ed Message buffer (0-15)
   1195          

   \                                 In section .text, align 2, keep-with-next
   1196          void CAN1_BUS_OFF_IRQHandler(void){}   //38:  CAM 1 Bus Off
   \                     CAN1_BUS_OFF_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1197          void CAN1_ERR_IRQHandler(void){}       //39:  CAM 1 Error
   \                     CAN1_ERR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1198          void CAN1_TW_IRQHandler(void){}        //40:  CAM 1 Transmit Warning
   \                     CAN1_TW_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1199          void CAN1_RW_IRQHandler(void){}        //41:  CAM 1 Receive Warning
   \                     CAN1_RW_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1200          void CAN1_WAKE_UP_IRQHandler(void){}   //42:  CAM 1 WakeUp
   \                     CAN1_WAKE_UP_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1201          void CAN1_IMEU_IRQHandler(void){}      //43:  CAM 1 Individual Matching Elements Update (IMEU)
   \                     CAN1_IMEU_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1202          void CAN1_LR_IRQHandler(void){}        //44:  CAM 1 Lost receive
   \                     CAN1_LR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x000F4241         DC32     0xf4241

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40024000         DC32     0x40024000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x4004A048         DC32     0x4004a048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x4004A04C         DC32     0x4004a04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x40049034         DC32     0x40049034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x0003D090         DC32     0x3d090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x........         DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \   00000000   0x400A4000         DC32     0x400a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \   00000000   0x........         DC32     CAN0_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \   00000000   0x........         DC32     CAN1_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \   00000000   0x1FFC0000         DC32     0x1ffc0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_25:
   \   00000000   0x........         DC32     flexcan_msgobj_param_t

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 "D:\\2019.IAR\\lib\\LPLD\\HW\\HW_CAN.c"
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x39 0x2E    
   \              0x49 0x41    
   \              0x52 0x5C    
   \              0x6C 0x69    
   \              0x62 0x5C    
   \              0x4C 0x50    
   \              0x4C 0x44    
   \              0x5C 0x48    
   \              0x57 0x5C    
   \              0x48 0x57    
   \              0x5F 0x43    
   \              0x41 0x4E    
   \              0x2E 0x63    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   1203          
   1204          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN0_BUS_OFF_IRQHandler
       0   CAN0_ERR_IRQHandler
       0   CAN0_IMEU_IRQHandler
       0   CAN0_LR_IRQHandler
       8   CAN0_MESS_IRQHandler
         8   -> LPLD_CAN_CAN0_Interrupt_Handler
       0   CAN0_RW_IRQHandler
       0   CAN0_TW_IRQHandler
       0   CAN0_WAKE_UP_IRQHandler
       0   CAN1_BUS_OFF_IRQHandler
       0   CAN1_ERR_IRQHandler
       0   CAN1_IMEU_IRQHandler
       0   CAN1_LR_IRQHandler
       8   CAN1_MESS_IRQHandler
         8   -> LPLD_CAN_CAN1_Interrupt_Handler
       0   CAN1_RW_IRQHandler
       0   CAN1_TW_IRQHandler
       0   CAN1_WAKE_UP_IRQHandler
      16   LPLD_CAN_CAN0_Interrupt_Handler
        16   -> LPLD_CAN_Receive_Interrupt
        16   -> LPLD_CAN_Transmit_Interrupt
      16   LPLD_CAN_CAN1_Interrupt_Handler
        16   -> LPLD_CAN_Receive_Interrupt
        16   -> LPLD_CAN_Transmit_Interrupt
       8   LPLD_CAN_Deinit
         8   -> NVIC_DisableIRQ
         8   -> NVIC_EnableIRQ
       8   LPLD_CAN_DisableIrq
         8   -> NVIC_DisableIRQ
       8   LPLD_CAN_EnableIrq
         8   -> NVIC_EnableIRQ
       0   LPLD_CAN_EnableMsgInterrupt
      16   LPLD_CAN_GetData
       0   LPLD_CAN_GetMsgCode
       0   LPLD_CAN_GetMsgID
       0   LPLD_CAN_GetMsgLength
       0   LPLD_CAN_GetMsgTimeStamp
      40   LPLD_CAN_Init
        40   -> LPLD_CAN_SetBaudRate
        40   -> assert_failed
      32   LPLD_CAN_InitMessageObject
        32   -> LPLD_CAN_EnableMsgInterrupt
        32   -> LPLD_CAN_SetMsgID
       0   LPLD_CAN_Interrupt_ClearPending
       0   LPLD_CAN_Interrupt_GetFlag
      16   LPLD_CAN_Receive_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
      48   LPLD_CAN_ReceivedMessage
        48   -> LPLD_CAN_GetData
        48   -> LPLD_CAN_GetMsgCode
        48   -> LPLD_CAN_GetMsgID
        48   -> LPLD_CAN_GetMsgLength
        48   -> LPLD_CAN_GetMsgTimeStamp
        48   -> LPLD_CAN_Interrupt_ClearPending
        48   -> LPLD_CAN_SetMsgCode
        48   -> LPLD_CAN_UnlockMsg
        48   -> memcpy
      16   LPLD_CAN_SetBaudRate
        16   -> assert_failed
       0   LPLD_CAN_SetMsgCode
       0   LPLD_CAN_SetMsgID
       0   LPLD_CAN_SetMsgLength
      40   LPLD_CAN_TransmitMessage
        40   -> LPLD_CAN_GetMsgCode
        40   -> LPLD_CAN_SetMsgID
        40   -> LPLD_CAN_SetMsgLength
        40   -> LPLD_CAN_WriteData
      16   LPLD_CAN_Transmit_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
       0   LPLD_CAN_UnlockMsg
      24   LPLD_CAN_WriteData
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      36  ?_0
       8  ?_1
       2  CAN0_BUS_OFF_IRQHandler
       2  CAN0_ERR_IRQHandler
       2  CAN0_IMEU_IRQHandler
      64  CAN0_ISR
       2  CAN0_LR_IRQHandler
      10  CAN0_MESS_IRQHandler
       2  CAN0_RW_IRQHandler
       2  CAN0_TW_IRQHandler
       2  CAN0_WAKE_UP_IRQHandler
       2  CAN1_BUS_OFF_IRQHandler
       2  CAN1_ERR_IRQHandler
       2  CAN1_IMEU_IRQHandler
      64  CAN1_ISR
       2  CAN1_LR_IRQHandler
      10  CAN1_MESS_IRQHandler
       2  CAN1_RW_IRQHandler
       2  CAN1_TW_IRQHandler
       2  CAN1_WAKE_UP_IRQHandler
      62  LPLD_CAN_CAN0_Interrupt_Handler
      62  LPLD_CAN_CAN1_Interrupt_Handler
      84  LPLD_CAN_Deinit
      34  LPLD_CAN_DisableIrq
      34  LPLD_CAN_EnableIrq
      36  LPLD_CAN_EnableMsgInterrupt
     108  LPLD_CAN_GetData
      16  LPLD_CAN_GetMsgCode
      50  LPLD_CAN_GetMsgID
      18  LPLD_CAN_GetMsgLength
      14  LPLD_CAN_GetMsgTimeStamp
     598  LPLD_CAN_Init
     202  LPLD_CAN_InitMessageObject
      36  LPLD_CAN_Interrupt_ClearPending
      30  LPLD_CAN_Interrupt_GetFlag
      92  LPLD_CAN_Receive_Interrupt
     174  LPLD_CAN_ReceivedMessage
     146  LPLD_CAN_SetBaudRate
      32  LPLD_CAN_SetMsgCode
      44  LPLD_CAN_SetMsgID
      32  LPLD_CAN_SetMsgLength
     138  LPLD_CAN_TransmitMessage
      92  LPLD_CAN_Transmit_Interrupt
       6  LPLD_CAN_UnlockMsg
     210  LPLD_CAN_WriteData
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
     256  flexcan_msgobj_param_t

 
   384 bytes in section .bss
    44 bytes in section .rodata
 2 546 bytes in section .text
 
 2 546 bytes of CODE  memory
    44 bytes of CONST memory
   384 bytes of DATA  memory

Errors: none
Warnings: none
